= Rubylog - Prolog interpreter for ruby

Rubylog is an implementation of (part of) the Prolog language as a Ruby DSL. The DSL is inspired by {Jamis Buck}[http://weblog.jamisbuck.org/2006/10/28/prolog-in-ruby], and the implementation is based on {Yield Prolog}[http://yieldprolog.sourceforge.net/].

== Installing
  $ gem install rubylog

== Using

To get started you have to do three things: require rubylog, include Rubylog::DSL::Constants and declare some functors on a class you want to use:
  require 'rubylog'
  include Rubylog::DSL::Constants
  Symbol.rubylog_functor :likes, :drinks, :has

A Rubylog clause can be created by sending the functor to the first argument, passing the other arguments:
  :john.likes :beer       # likes(john,beer) in Prolog

A variable is an undefined constant. Don't-care variables start with ANY...
  A, B, Cat               # the same in Prolog
  ANY, ANYONE, ANYTHING   # _ in Prolog

Now you can start writing Rubylog predicates. Facts can be asserted with a bang:
  :john.likes! :beer      # likes(john, beer). in Prolog
  :john.has! :beer      

Fact assertions return the first argument, so they can be chained:
  :john.likes!(:beer).has!(:beer)

Rules can be asserted with +if+ and +unless+:
  X.drinks(Y).if X.has(Y).and X.likes(Y)         # drinks(X,Y) :- has(X,Y), likes(X,Y). in Prolog

Queries can be proved with a question mark or with +true?+:
  :john.drinks? :beer         # => true
  (:john.drinks :beer).true?  # => true

Or solutions can be enumerated (clauses include Enumerable)
  (:john.drinks X).each {|x| p x}  # outputs :beer
  (:john.drinks X).to_a            # => [:beer]

At most places you can mix native Ruby with Rubylog by using a proc instead of a clause. Blocks are automatically converted to proc objects:
  X.drinks(Y).if proc{|x,y| y.to_s =~ /^Z/ }
  X.drinks(Y).if {|x,y| y.to_s =~ /^Z/ }     # the same

  X.drinks(Y).if X.likes(Y).and proc { Time.now.hour == 12 }
  X.drinks(Y).if X.likes(Y).and { Time.now.hour == 12 }     # the same

Variable values are passed to the proc, in the order of appearance.

Nullary predicates are just symbols:
  :john.drinks(:beer).if :true.or :false

For predicates requiring a simple value as an argument, you can pass a proc that returns that value
  X.drinks(Y).if Y.is proc{|x| $favorites[x] }
  X.drinks(Y).if Y.is {|x| $favorites[x] }      # the same


The Prolog built-in predicates and the Rubylog equivalents (see +Rubylog::Builtins+ for details):

  Prolog              Rubylog
  ----------------------------------------
  true                true
  fail                fail
  ,                   and, &
  ;                   or, |
  !                   :cut
  ->                  then
  \+                  is_false, fails, not, ~
  repeat              repeat
  A=B                 A.is B
  X is Y*5            X.is{|y|y*5}
                      proc{|x,y|y===x} or X.matches Y
  L=[H|T]             L.splits_to(H,T)
  member(A,L)         A.in L (L can be any enumerable)
  write(A)            A._puts, A._print, A._p
  nl                  nl
  \+((A, \+ B))       A.all B
  (A,B)->true         A.any B
                      A.one B
  \+((A,B))           A.none B
  A,fail;true         A.all
  A->true             A.any
                      A.one
  \+(A)               A.none




== Contributing to rubylog
* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet.
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it.
* Fork the project.
* Start a feature/bugfix branch.
* Commit and push until you are happy with your contribution.
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

== Copyright

Copyright (c) 2012 Bernát Kalló. See LICENSE.txt for
further details.

