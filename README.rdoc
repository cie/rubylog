= Rubylog - Prolog interpreter for ruby

Rubylog is a Prolog-like DSL for Ruby. The language is inspired by {Jamis
Buck}[http://weblog.jamisbuck.org/2006/10/28/prolog-in-ruby], and the
implementation is based on {Yield Prolog}[http://yieldprolog.sourceforge.net/],
with lots of sintactic and semantic candy.

See the {wiki}[https://github.com/cie/rubylog/wiki] for online documentation.

== Getting started

Currently, Rubylog only works with Ruby 1.9.2. 

First, install the gem

  $ gem install rubylog-2.0pre1

or, if you use +bundler+, add this line to your +Gemfile+:

  gem 'rubylog', '~>2.0pre1'



Secondly, you need a Rubylog context. The simplest you can do is to extend Rubylog::Context into the main object.

  require 'rubylog'
  extend Rubylog::Context

Another option is to use Kernel#rubylog:


  require 'rubylog'
  extend Rubylog::Context

  rubylog do
    # your code here
  end


=== Data types

Rubylog is similar to Prolog, but there are quite a few differences. In Rubylog,
you can use any Ruby object as data, also +nil+.

Rubylog variables are (undefined) constant names:

  A, B, ANYTHING

A variable whose name starts with +ANY...+ (case-insensitive) is a don't-care
variable (like +_+ in Prolog).

Lists are just Ruby arrays:

  [1, 2, 3]

They can have splats:

  [1, 2, *T]

Which would be <tt>[1,2|T]</tt> in Prolog, however, in Rubylog, splats are not limited
to the end:

  [1, *A, 5]
  [*A, *B]

=== Predicates
As in prolog, predicates are the buinding blocks of your program. However, the arguments are in a different order than they are in prolog:

  predicate_for String, ".likes()"
  'John'.likes!('beer')

which would be <tt>likes('John','beer').</tt> in prolog.

In Rubylog, predicates must be declared with +predicate_for+. The string indicating the predicate syntax is <tt>".likes()"</tt>. The format is <tt>:asdf .asdf .asdf() .asdf(,) .asdf(,,)</tt> for predicates with 0,1,2,3,4 arguments. You can add descriptions in the indicator string like <tt>"Person.likes(Drink)"</tt>

You can assert a rule with the +if+ method:

  predicate_for String, ".drinks() .has()"
  X.drinks(Y).if X.has(Y).and X.likes(Y)        

This would be +drinks(X,Y) :- has(X,Y), likes(X,Y)+ in Prolog.

You can assert facts with <tt>if(:true)</tt>, or with the bang syntax:

  'John'.likes! 'milk'                         

Bang assertions return their first argument (which is <tt>'John'</tt> in this case), so they can be chained:

  'John'.likes!('beer').has!('beer')

You can also use +unless+:

  predicate_for String, ".good .bad"
  A.good.unless A.bad              

Nullary predicates are symbols, similar to Prolog:

  'John'.drinks('beer').if :false.and(:cut!).or(:true)



=== Built-in predicates

Some built-in predicates and their Prolog equivalents:

  Rubylog  Prolog
  -------  ------ 
  :true     true
  :fail     fail
  .and()    ,
  .or()     ;
  :false    \+
  .is()     =
  .is_not() =/=
  .in()     member
  :cut!     !

There are some new ones:

  not_in, all, any, one, none, iff, every

You can see reference of these in <tt>lib/rubylog/builtins/logic.rb</tt> and <tt>lib/rubylog/builtins/term.rb</tt>


=== Unification

In Rubylog, unification works quite like in Prolog, but with the +is+ functor.

  A.is(B)

Using arrays, you can benefit the splats:

  [1,2,3,4].is([A,B,*T])      # [1,2,3,4] = [A,B|T]     in prolog
  [1,2,3,4].is([*H,*T])       # append(H, T, [1,2,3,4]) in prolog

The +in+ predicate unifies the first argument with any member of the collection:

  4.in([1,2,3,4])             # member(4,[1,2,3,4]) in prolog

You can use guards. These are constant expressions that restrict the unification of variables. There are several types of guards:

  A[String].in(["asdf",5,nil]).each { p A }     # outputs "asdf"
  A[/x/].in(["asdf","xyz"]).each { p A }        # outputs "xyz"
  A[length: 3].in(["abc","abcd"]).each { p A }  # outputs "abc"
  A[thats < 5].in([4,5,6]).each { p A }         # outputs 4
  A[thats.length + 1 == 5].in(["abc","abcd"]).each { p A }    # outputs "abcd"

+thats+ can receive any number of messages chained, and this will be applied to the value that would be bound to the variable. 
You can add various guards to a variable.

  A[Integer, thats%2 ==0].even!


=== Moving between Ruby and Rubylog
==== Running a query

If you want to run a query, you have three different syntaxes:

  true? ('John'.drinks 'beer')  # => true
  ('John'.drinks 'beer').true?  # => true
  'John'.drinks? 'beer'         # => true

==== Finding solutions

+Structure+ implements +Enumerable+, and yields the solutions. Within the
enumeration block, you can access the values of your variables.

  'John'.drinks! 'beer'
  ('John'.drinks X).each {p X}      # outputs 'beer'
  ('John'.drinks X).map{X}          # => ['beer']
  ('John'.drinks X).count           # => 1

You can also use +solve+, which is equivalent with +each+.

==== Procs as predicates

You can invoke Ruby codes in Rubylog rules with a proc:

  'John'.likes(Y).if proc{ Y =~ /ale/ }

or in most cases you can use just a block:

  'John'.likes(Y).if { Y =~ /ale/ }

The predicate succeeds if the block returns a true value.

==== Procs as functions

+is+ and +in+ can take a proc or block argument, which they execute and take its return value:

  X.good.if X.is { 'BEER'.downcase }
  X.good.if X.in { get_good_drinks() }

==== Variables in blocks

When you use blocks or procs as predicates or functions, or when you use enumeration methods with blocks, you can access values of variables by their name in the blocks (if they are bound).


  'John'.likes(Y).if { Y =~ /ale/ }
  'John'.likes(Y).if Y.is { Y =~ /ale/ }
  'John'.likes(Y).each { p Y }

If your variable is unbound, you will get the variable object.

  X.is(Y).each { p X.class }   # outputs 'Rubylog::Variable'


=== Rspec integration

Rubylog can integrate with RSpec. This enables you to use variables and predicates in specs.

  require "rspec/rubylog"

  describe "numbers", rubylog: true do
    specify do
      A.is(5).map{A}.should == [5]
    end
  end

There is an assertion method called +check+ that receives a predicate as an argument and raises an exception if it fails.

  check 5.is(5)

=== Built-in predicates

==== File system

You can make some queries on the file system:

  check "README".filename_in "."
  check "./README".file_in "."

  X.dirname_in(".").each { puts X }


==== Reflection

You can make some metaprogramming with Rubylog


    predicate_for String, ".likes()"

    check "John".likes("Jane").structure(Pred, :likes, ["John", "Jane"])

    "John".likes(X).if X.likes("John")
    "Jane".likes!("John")
    check "John".likes("Jane").follows_from "Jane".likes("John")

    "John".likes!("milk")
    check "John".likes("milk").fact
    check "John".likes("beer").fact.false

  end

==== Arithmetics

  check 5.sum_of(2,3)
  check 5.product_of(1,5)

These work as expected if you provide any two of the three paramters. For example,

  A.in(1..21).and(21.product_of(A,B)).each do
    p [A,B]
  end

== Contributing

=== To the language

* If you have a suggestion for the language, submit an issue.

=== Reporting bugs or requesting features

* Create an issue on the {issue tracker}[https://github.com/cie/rubylog/issues].

== Copyright

Copyright (c) 2013 Bernát Kalló. See LICENSE.txt for
further details.

