= Rubylog - Prolog interpreter for ruby

Rubylog is a Prolog-like DSL for Ruby. The language is inspired by {Jamis
Buck}[http://weblog.jamisbuck.org/2006/10/28/prolog-in-ruby], and the
implementation is based on {Yield Prolog}[http://yieldprolog.sourceforge.net/],
with lots of sintactic and semantic candy.

See the {wiki}[https://github.com/cie/rubylog/wiki] for online documentation.

== Getting started

Currently, Rubylog only works with Ruby 1.9.2. 

First, install the gem

  $ gem install rubylog-2.0pre1

or, if you use +bundler+, add this line to your +Gemfile+:

  gem 'rubylog', '~>2.0pre1'



Secondly, you need a Rubylog context. The simplest you can do is to extend Rubylog::Context into the main object.

  require 'rubylog'
  extend Rubylog::Context

Another option is to use Kernel#rubylog:


  require 'rubylog'
  extend Rubylog::Context

  rubylog do
    # your code here
  end


=== Data types

Rubylog is similar to Prolog, but there are quite a few differences.

Rubylog variables are (undefined) constant names:

  A, B, ANYTHING

A variable can be bound or unbound, and it contains a Ruby object when bound. A variable whose name starts with +ANY...+ (case-insensitive) is a don't-care
variable (like +_+ in Prolog).

Lists are just Ruby arrays:

  [1, 2, 3]

They can have splats:

  [1, 2, *T]

Which would be <tt>[1,2|T]</tt> in Prolog. However, in Rubylog, splats are not limited
to the end:

  [1, *X, 5]
  [*A, *B]

=== Predicates
As in prolog, predicates are the building blocks of your program. However, the arguments are in a different order than they are in prolog:

  predicate_for String, ".likes()"
  'John'.likes('beer')

which would be <tt>likes('John','beer')</tt> in prolog. As you can see, the first argument comes first, then the functor, and then the further arguments.  

In Rubylog, predicates must be declared with +predicate_for+. You have to specify the class of the possible first arguments, this is called the subject class. This could also be an array of classes. The string indicating the predicate syntax is <tt>".likes()"</tt>. The format is <tt>.asdf .asdf() .asdf(,) .asdf(,,)</tt> for predicates with 0,1,2,3,4 arguments. You can add descriptions in the indicator string e.g. <tt>"Person.likes(Drink)"</tt> means the same as <tt>".likes()"</tt>.

Nullary predicates are symbols, and they have to be declared with +predicate+:

  predicate ":asdf"
  :asdf

Declaring a predicate with arguments gives you three methods on the subject class:

  predicate_for String, ".likes()"
  'John'.likes('beer')    # returns a structure object representing this logical statement
  'John'.likes!('beer')   # asserts that this statement is a fact
  'John'.likes?('beer')   # tells if this statement is true (in this case, returns true)

=== Asserting clauses

As in Prolog, there are two types of clauses, rules and facts. You can assert a rule with the +if+ method:

  predicate_for String, ".drinks() .has()"
  X.drinks(Y).if X.has(Y).and X.likes(Y)        

This would be <tt>drinks(X,Y) :- has(X,Y), likes(X,Y)</tt> in Prolog.

You can assert facts with the bang syntax:

  'John'.likes! 'milk'                         

This would be <tt>likes('John','beer').</tt> in Prolog. Bang assertions return their first argument (which is <tt>'John'</tt> in this case), so they can be chained:

  'John'.likes!('beer').has!('beer')

You can also use +unless+:

  predicate_for String, ".good .bad"
  A.good.unless A.bad              


=== Built-in predicates

Some built-in predicates and their Prolog equivalents:

  Rubylog  Prolog
  -------  ------ 
  :true     true
  :fail     fail
  .and()    ,
  .or()     ;
  :false    \+
  .is()     =
  .is_not() =/=
  .in()     member
  :cut!     !

There are some new ones:

  not_in, all, any, one, none, iff, every

You can see reference of these in <tt>lib/rubylog/builtins/logic.rb</tt> and <tt>lib/rubylog/builtins/term.rb</tt>


=== Unification

In Rubylog, unification works like in Prolog, but with the +is+ functor.

  A.is(B)

Using arrays, you can benefit the splats:

  [1,2,3,4].is([A,B,*T])      # [1,2,3,4] = [A,B|T]     in prolog
  [1,2,3,4].is([*H,*T])       # append(H, T, [1,2,3,4]) in prolog

The +in+ predicate unifies the first argument with any member of the collection:

  4.in([1,2,3,4])             # member(4,[1,2,3,4]) in prolog

=== Guards

You can use guards. These are constant expressions that restrict the unification of variables. There are several types of guards:

  A[String].in(["asdf",5,nil]).each { p A }     # outputs "asdf"
  A[/x/].in(["asdf","xyz"]).each { p A }        # outputs "xyz"
  A[length: 3].in(["abc","abcd"]).each { p A }  # outputs "abc"
  A[thats < 5].in([4,5,6]).each { p A }         # outputs 4
  A[thats.length + 1 == 5].in(["abc","abcd"]).each { p A }    # outputs "abcd"

+thats+ can receive any number of messages chained, and this will be applied to the value that would be bound to the variable. 
You can add various guards to a variable. +thats\_not+ is the negation of +thats+.

  A[Integer, thats%2 ==0].even!

Currently, you cannot use variables in guards.


=== Moving between Ruby and Rubylog
==== Running a query

If you want to run a query, you have three different syntaxes:

  true? ('John'.drinks 'beer')  # => true
  ('John'.drinks 'beer').true?  # => true
  'John'.drinks? 'beer'         # => true

==== Finding solutions

+Structure+ implements +Enumerable+, and yields the solutions. Within the
enumeration block, you can access the values of your variables.

  'John'.drinks! 'beer'
  ('John'.drinks X).each {p X}      # outputs 'beer'
  ('John'.drinks X).map{X}          # => ['beer']
  ('John'.drinks X).count           # => 1

You can also use +solve+, which is equivalent with +each+.

==== Procs as predicates

You can invoke Ruby codes in Rubylog rules with a proc:

  'John'.likes(Y).if proc{ Y =~ /ale/ }

or in most cases you can use just a block:

  'John'.likes(Y).if { Y =~ /ale/ }

The predicate succeeds if the block returns a true value.

==== Procs as functions

+is+ and +in+ can take a proc or block argument, which they execute and take its return value:

  X.good.if X.is { 'BEER'.downcase }
  X.good.if X.in { get_good_drinks() }

==== Variables in blocks

When you use blocks or procs as predicates or functions, or when you use enumeration methods with blocks, you can access values of variables by their name in the blocks (if they are bound).


  'John'.likes(Y).if { Y =~ /ale/ }
  'John'.likes(Y).if Y.is { Y =~ /ale/ }
  'John'.likes(Y).each { p Y }

If your variable is unbound, you will get the variable object.

  X.is(Y).each { p X.class }   # outputs 'Rubylog::Variable'


=== Rspec integration

Rubylog can integrate with RSpec. This enables you to use variables and predicates in specs.

  require "rspec/rubylog"

  describe "numbers", rubylog: true do
    specify do
      A.is(5).map{A}.should == [5]
    end
  end

There is an assertion method called +check+ that receives a predicate as an argument and raises an exception if it fails.

  check 5.is(5)

=== Built-in predicates

==== File system

You can make some queries on the file system:

  check "README".filename_in "."
  check "./README".file_in "."

  X.dirname_in(".").each { puts X }


==== Reflection

You can make some metaprogramming with Rubylog


    predicate_for String, ".likes()"

    check "John".likes("Jane").structure(Pred, :likes, ["John", "Jane"])

    "John".likes(X).if X.likes("John")
    "Jane".likes!("John")
    check "John".likes("Jane").follows_from "Jane".likes("John")

    "John".likes!("milk")
    check "John".likes("milk").fact
    check "John".likes("beer").fact.false

  end

==== Arithmetics

  check 5.sum_of(2,3)
  check 5.product_of(1,5)

These work as expected if you provide any two of the three paramters. For example,

  10.sum_of(6,A).solve { p A }  # outputs 4

  A.in(1..21).and(21.product_of(A,B)).each do
    p [A,B]
  end # outputs pairs of divisors

== Contributing

=== To the language

* If you have a suggestion for the language, submit an issue.

=== Reporting bugs or requesting features

* Create an issue on the {issue tracker}[https://github.com/cie/rubylog/issues].

== Copyright

Copyright (c) 2013 Bernát Kalló. See LICENSE.txt for
further details.

