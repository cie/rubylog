= Rubylog - Prolog interpreter for ruby

Rubylog is a language similar to Prolog implemented as a Ruby DSL. The language is inspired by {Jamis Buck}[http://weblog.jamisbuck.org/2006/10/28/prolog-in-ruby], and the implementation is based on {Yield Prolog}[http://yieldprolog.sourceforge.net/].

== Installing
  $ gem install rubylog

Or, if you use +bundler+:
  gem 'rubylog', '~>1.0.0'

== Using

First, you have to enter in Rubylog mode with the theory method:

  require 'rubylog'
  theory "MyTheory" do
    # your code here
  end

Rubylog is similar to Prolog, but with a few differences.

In rubylog, you can use any object as 

A Rubylog structures swap the first argument with the functor. They can be created by calling a method. You have to declare the functor first:
  functor :likes
  :john.likes :beer       # likes(john,beer) in Prolog

A variable can be written as any non-defined constant. Don't-care variables start with ANY...
  A, B, Cat               # the same in Prolog
  ANY, ANYONE, ANYTHING   # _ in Prolog

Now you can start writing Rubylog predicates. Facts can be asserted with a bang:
  :john.likes! :beer      # likes(john, beer). 
  :john.has! :beer        # has(john, beer). 

Fact assertions return the first argument, so they can be chained:
  :john.likes!(:beer).has!(:beer)

Rules can be asserted with +if+ and +unless+:
  X.drinks(Y).if X.has(Y).and X.likes(Y)         # drinks(X,Y) :- has(X,Y), likes(X,Y).
  A.good.unless A.bad                            # good(A) :- \+(bad(A)).

Queries can be proved a few different ways:
  :john.drinks? :beer         # => true
  (:john.drinks :beer).true?  # => true
  true? (:john.drinks :beer)  # => true
  prove (:john.drinks :beer)  # => true

Solutions can be enumerated (Structure < Enumerable)
  (:john.drinks X).each {p X}      # outputs :beer
  (:john.drinks X).map{X}          # => [:beer]
  (:john.drinks X).count           # => 1
These blocks are evaluated in dynamic mode, where variables are substituted with their value.

You can use a block or a proc instead of a clause. 
  X.drinks(Y).if X.has(Y)
  X.drinks(Y).if {Y.to_s =~ /ale\Z/i}
  X.drinks(Y).if proc { Y.to_s =~ /ale\Z/i } .and { Time.now.hour == 12 }     
These blocks are evaluated in dynamic mode.

You can write nullary predicates as symbols.
  :john.drinks(:beer).if :false.and(:cut!).or(:true)

You can use a block or a proc instead of a value in the predicates +is+, +in+:
  X.drinks(Y).if Y.is { "BEER".downcase.to_sym }
  X.drinks(Y).if Y.in { $favorites }

You can use a variable as a comprehension to create a partial list:
  [1,2,3].is [A,*R]    # => A=1, R=[2,3]
  [1,2,3].is [A]+R  

The Prolog built-in predicates and the Rubylog equivalents (see +Rubylog::Builtins+ for details):

  Prolog              Rubylog
  ----------------------------------------
  true                :true
  fail                :fail
  ,                   and  &
  ;                   or  |
  !                   :cut!
  ->                  
  \+                  false  none
  repeat              
  A=B                 A.is B
  X is Y*5            X.is{Y*5}
  L=[H|T]             L.is [H,*T]   L.is [H]+T
  append(A,B,L)       L.is [*A,*B]
  member(A,L)         A.in L   L.is [*ANY,A,*ANY] 
  write(A)            { p A }
  nl                  { puts }
  \+((A, \+ B))       A.all B
  (A,B)->true         A.any B
                      A.one B
  \+((A,B))           A.none B
  A->true             A.any
                      A.one
  findall(V,G,L)      L.is{G.map{V}}




== Contributing

=== To the language
* Post the code sample in a gist.
* Create an issue on the {issue tracker}[https://github.com/cie/rubylog/issues] and link to the gist.

=== To the interpreter
* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet.
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it.
* Fork the project.
* Start a feature/bugfix branch.
* Commit and push until you are happy with your contribution.
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

== Copyright

Copyright (c) 2012 Bernát Kalló. See LICENSE.txt for
further details.

